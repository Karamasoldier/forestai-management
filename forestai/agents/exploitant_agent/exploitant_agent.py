# -*- coding: utf-8 -*-
"""
Module principal pour l'ExploitantAgent.

Ce module implémente la classe ExploitantAgent qui gère les opérateurs forestiers,
le suivi des interventions et l'évaluation des performances.
"""

import logging
import json
import uuid
from typing import Dict, Any, List, Optional, Union
from datetime import datetime, date
from pathlib import Path

from forestai.core.utils.logging_utils import get_logger
from forestai.core.base.agent import BaseAgent
from forestai.agents.exploitant_agent.managers.operators_manager import OperatorsManager
from forestai.agents.exploitant_agent.managers.operations_manager import OperationsManager
from forestai.agents.exploitant_agent.managers.performance_manager import PerformanceManager

logger = get_logger(__name__)

class ExploitantAgent(BaseAgent):
    """
    Agent pour la gestion des opérateurs forestiers et de leurs interventions.
    
    Cette classe fournit des fonctionnalités pour suivre les opérateurs forestiers,
    planifier et suivre les interventions sylvicoles, et évaluer les performances des travaux.
    """
    
    def __init__(self, config_path: Optional[Union[str, Path]] = None):
        """
        Initialise l'ExploitantAgent.
        
        Args:
            config_path: Chemin vers le fichier de configuration (facultatif)
        """
        super().__init__(name="ExploitantAgent", config_path=config_path)
        
        # Initialiser les gestionnaires de données pour les opérateurs, interventions, etc.
        self._init_data_managers()
        
        # Enregistrer les actions disponibles de l'agent
        self._register_actions()
        
        logger.info("ExploitantAgent initialisé")
    
    def _init_data_managers(self):
        """
        Initialise les gestionnaires de données pour l'ExploitantAgent.
        """
        # Configurer le répertoire de données partagé pour tous les gestionnaires
        data_dir = self.config.get("data_dir")
        if data_dir:
            data_dir = Path(data_dir)
        else:
            # Utiliser le répertoire par défaut basé sur les variables d'environnement
            data_dir = None
            
        # Initialiser les gestionnaires
        self.operators_manager = OperatorsManager(data_dir)
        self.operations_manager = OperationsManager(data_dir)
        self.performance_manager = PerformanceManager(data_dir)
    
    def _register_actions(self):
        """
        Enregistre les actions disponibles pour l'agent.
        """
        self.register_action("get_operators", self.get_operators)
        self.register_action("get_operator_details", self.get_operator_details)
        self.register_action("add_operator", self.add_operator)
        self.register_action("update_operator", self.update_operator)
        self.register_action("get_operations", self.get_operations)
        self.register_action("get_operation_details", self.get_operation_details)
        self.register_action("schedule_operation", self.schedule_operation)
        self.register_action("update_operation_status", self.update_operation_status)
        self.register_action("evaluate_performance", self.evaluate_performance)
        self.register_action("generate_performance_report", self.generate_performance_report)
        self.register_action("search_operators", self.search_operators)
        self.register_action("search_operations", self.search_operations)
        self.register_action("get_operators_by_certification", self.get_operators_by_certification)
        self.register_action("get_operations_by_period", self.get_operations_by_period)
        self.register_action("get_operator_performance_summary", self.get_operator_performance_summary)
    
    # --- Actions de gestion des opérateurs ---
    
    def get_operators(self, params: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        Récupère la liste des opérateurs forestiers.
        
        Args:
            params: Paramètres de filtrage (facultatif)
            
        Returns:
            Dictionnaire contenant la liste des opérateurs
        """
        try:
            operators = self.operators_manager.get_operators(params)
            
            return {
                "status": "success",
                "result": {
                    "operators": [op.to_dict() for op in operators],
                    "count": len(operators)
                }
            }
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des opérateurs: {str(e)}")
            return {
                "status": "error",
                "error_message": f"Erreur lors de la récupération des opérateurs: {str(e)}"
            }
    
    def get_operator_details(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Récupère les détails d'un opérateur forestier spécifique.
        
        Args:
            params: Paramètres de la requête, doit contenir 'operator_id'
            
        Returns:
            Dictionnaire contenant les détails de l'opérateur
        """
        operator_id = params.get("operator_id")
        if not operator_id:
            return {
                "status": "error",
                "error_message": "L'identifiant de l'opérateur est requis"
            }
        
        try:
            operator = self.operators_manager.get_operator(operator_id)
            
            if not operator:
                return {
                    "status": "error",
                    "error_message": f"Opérateur avec ID {operator_id} non trouvé"
                }
            
            return {
                "status": "success",
                "result": operator.to_dict()
            }
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des détails de l'opérateur {operator_id}: {str(e)}")
            return {
                "status": "error",
                "error_message": f"Erreur lors de la récupération des détails de l'opérateur: {str(e)}"
            }
    
    def add_operator(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Ajoute un nouvel opérateur forestier.
        
        Args:
            params: Informations sur l'opérateur à ajouter
            
        Returns:
            Dictionnaire contenant le résultat de l'opération
        """
        # Vérifier les paramètres requis
        required_fields = ["name", "type"]
        for field in required_fields:
            if field not in params:
                return {
                    "status": "error",
                    "error_message": f"Le champ '{field}' est requis"
                }
        
        try:
            operator = self.operators_manager.add_operator(params)
            
            if not operator:
                return {
                    "status": "error",
                    "error_message": "Échec de l'ajout de l'opérateur"
                }
            
            return {
                "status": "success",
                "result": {
                    "operator_id": operator.id,
                    "message": f"Opérateur '{operator.name}' ajouté avec succès"
                }
            }
        except Exception as e:
            logger.error(f"Erreur lors de l'ajout de l'opérateur: {str(e)}")
            return {
                "status": "error",
                "error_message": f"Erreur lors de l'ajout de l'opérateur: {str(e)}"
            }
    
    def update_operator(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Met à jour les informations d'un opérateur forestier existant.
        
        Args:
            params: Informations à mettre à jour, doit contenir 'operator_id'
            
        Returns:
            Dictionnaire contenant le résultat de l'opération
        """
        operator_id = params.get("operator_id")
        if not operator_id:
            return {
                "status": "error",
                "error_message": "L'identifiant de l'opérateur est requis"
            }
        
        try:
            operator = self.operators_manager.update_operator(operator_id, params)
            
            if not operator:
                return {
                    "status": "error",
                    "error_message": f"Échec de la mise à jour de l'opérateur {operator_id}"
                }
            
            return {
                "status": "success",
                "result": {
                    "operator_id": operator.id,
                    "message": "Opérateur mis à jour avec succès"
                }
            }
        except Exception as e:
            logger.error(f"Erreur lors de la mise à jour de l'opérateur {operator_id}: {str(e)}")
            return {
                "status": "error",
                "error_message": f"Erreur lors de la mise à jour de l'opérateur: {str(e)}"
            }
    
    def search_operators(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Recherche des opérateurs par nom, spécialité, ou zone de travail.
        
        Args:
            params: Paramètres de recherche, doit contenir 'query'
            
        Returns:
            Dictionnaire contenant les résultats de la recherche
        """
        query = params.get("query")
        if not query:
            return {
                "status": "error",
                "error_message": "Le terme de recherche est requis"
            }
        
        try:
            operators = self.operators_manager.search_operators(query)
            
            return {
                "status": "success",
                "result": {
                    "operators": [op.to_dict() for op in operators],
                    "count": len(operators)
                }
            }
        except Exception as e:
            logger.error(f"Erreur lors de la recherche d'opérateurs avec '{query}': {str(e)}")
            return {
                "status": "error",
                "error_message": f"Erreur lors de la recherche d'opérateurs: {str(e)}"
            }
    
    def get_operators_by_certification(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Récupère les opérateurs ayant une certification spécifique.
        
        Args:
            params: Paramètres de filtrage, doit contenir 'certification'
            
        Returns:
            Dictionnaire contenant les opérateurs certifiés
        """
        certification = params.get("certification")
        if not certification:
            return {
                "status": "error",
                "error_message": "La certification est requise"
            }
        
        try:
            filters = {"certification": certification}
            operators = self.operators_manager.get_operators(filters)
            
            return {
                "status": "success",
                "result": {
                    "certification": certification,
                    "operators": [op.to_dict() for op in operators],
                    "count": len(operators)
                }
            }
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des opérateurs avec certification '{certification}': {str(e)}")
            return {
                "status": "error",
                "error_message": f"Erreur lors de la récupération des opérateurs certifiés: {str(e)}"
            }
    
    # --- Actions de gestion des opérations ---
    
    def get_operations(self, params: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        Récupère la liste des opérations forestières.
        
        Args:
            params: Paramètres de filtrage (facultatif)
            
        Returns:
            Dictionnaire contenant la liste des opérations
        """
        try:
            operations = self.operations_manager.get_operations(params)
            
            return {
                "status": "success",
                "result": {
                    "operations": [op.to_dict() for op in operations],
                    "count": len(operations)
                }
            }
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des opérations: {str(e)}")
            return {
                "status": "error",
                "error_message": f"Erreur lors de la récupération des opérations: {str(e)}"
            }
    
    def get_operation_details(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Récupère les détails d'une opération forestière spécifique.
        
        Args:
            params: Paramètres de la requête, doit contenir 'operation_id'
            
        Returns:
            Dictionnaire contenant les détails de l'opération
        """
        operation_id = params.get("operation_id")
        if not operation_id:
            return {
                "status": "error",
                "error_message": "L'identifiant de l'opération est requis"
            }
        
        try:
            operation = self.operations_manager.get_operation(operation_id)
            
            if not operation:
                return {
                    "status": "error",
                    "error_message": f"Opération avec ID {operation_id} non trouvée"
                }
            
            return {
                "status": "success",
                "result": operation.to_dict()
            }
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des détails de l'opération {operation_id}: {str(e)}")
            return {
                "status": "error",
                "error_message": f"Erreur lors de la récupération des détails de l'opération: {str(e)}"
            }
    
    def schedule_operation(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Planifie une nouvelle opération forestière.
        
        Args:
            params: Informations sur l'opération à planifier
            
        Returns:
            Dictionnaire contenant le résultat de l'opération
        """
        # Vérifier les paramètres requis
        required_fields = ["type", "operator_id", "parcel_id", "description", "area_ha"]
        for field in required_fields:
            if field not in params and field not in params.get("location", {}):
                return {
                    "status": "error",
                    "error_message": f"Le champ '{field}' est requis"
                }
        
        try:
            # Préparer les données avec la structure attendue
            operation_data = {
                "type": params["type"],
                "description": params["description"],
                "operator_id": params["operator_id"],
                "location": {
                    "parcel_id": params["parcel_id"],
                    "area_ha": params.get("area_ha", 0),
                    "commune": params.get("commune"),
                    "lieu_dit": params.get("lieu_dit"),
                    "coordinates": params.get("coordinates")
                },
                "schedule": {
                    "start_date": params.get("start_date"),
                    "end_date": params.get("end_date"),
                    "estimated_duration_days": params.get("estimated_duration_days")
                },
                "equipment": params.get("equipment", []),
                "estimated_volume_m3": params.get("estimated_volume_m3"),
                "notes": params.get("notes", ""),
                "tags": params.get("tags", [])
            }
            
            operation = self.operations_manager.add_operation(operation_data)
            
            if not operation:
                return {
                    "status": "error",
                    "error_message": "Échec de la planification de l'opération"
                }
            
            return {
                "status": "success",
                "result": {
                    "operation_id": operation.id,
                    "message": f"Opération '{operation.type.value}' planifiée avec succès"
                }
            }
        except Exception as e:
            logger.error(f"Erreur lors de la planification de l'opération: {str(e)}")
            return {
                "status": "error",
                "error_message": f"Erreur lors de la planification de l'opération: {str(e)}"
            }
    
    def update_operation_status(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Met à jour le statut d'une opération forestière.
        
        Args:
            params: Paramètres incluant 'operation_id' et 'status'
            
        Returns:
            Dictionnaire contenant le résultat de l'opération
        """
        operation_id = params.get("operation_id")
        status = params.get("status")
        
        if not operation_id or not status:
            return {
                "status": "error",
                "error_message": "L'identifiant de l'opération et le statut sont requis"
            }
        
        try:
            comment = params.get("comment")
            user = params.get("user")
            
            operation = self.operations_manager.update_operation_status(
                operation_id=operation_id,
                new_status=status,
                comment=comment,
                user=user
            )
            
            if not operation:
                return {
                    "status": "error",
                    "error_message": f"Échec de la mise à jour du statut de l'opération {operation_id}"
                }
            
            return {
                "status": "success",
                "result": {
                    "operation_id": operation.id,
                    "previous_status": operation.status_history[-2].status.value if len(operation.status_history) > 1 else None,
                    "current_status": operation.status.value,
                    "updated_at": datetime.now().isoformat(),
                    "message": f"Statut de l'opération mis à jour: {operation.status.value}"
                }
            }
        except Exception as e:
            logger.error(f"Erreur lors de la mise à jour du statut de l'opération {operation_id}: {str(e)}")
            return {
                "status": "error",
                "error_message": f"Erreur lors de la mise à jour du statut de l'opération: {str(e)}"
            }
    
    def search_operations(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Recherche des opérations par description ou lieu.
        
        Args:
            params: Paramètres de recherche, doit contenir 'query'
            
        Returns:
            Dictionnaire contenant les résultats de la recherche
        """
        query = params.get("query")
        if not query:
            return {
                "status": "error",
                "error_message": "Le terme de recherche est requis"
            }
        
        try:
            operations = self.operations_manager.search_operations(query)
            
            return {
                "status": "success",
                "result": {
                    "operations": [op.to_dict() for op in operations],
                    "count": len(operations)
                }
            }
        except Exception as e:
            logger.error(f"Erreur lors de la recherche d'opérations avec '{query}': {str(e)}")
            return {
                "status": "error",
                "error_message": f"Erreur lors de la recherche d'opérations: {str(e)}"
            }
    
    def get_operations_by_period(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Récupère les opérations prévues dans une période spécifique.
        
        Args:
            params: Paramètres de la requête, doit contenir 'start_date' et 'end_date'
            
        Returns:
            Dictionnaire contenant les opérations dans la période
        """
        start_date_str = params.get("start_date")
        end_date_str = params.get("end_date")
        
        if not start_date_str or not end_date_str:
            return {
                "status": "error",
                "error_message": "Les dates de début et de fin sont requises"
            }
        
        try:
            # Convertir les chaînes en dates
            if isinstance(start_date_str, str):
                if 'T' in start_date_str:
                    start_date = datetime.fromisoformat(start_date_str.replace('Z', '+00:00')).date()
                else:
                    start_date = datetime.strptime(start_date_str, "%Y-%m-%d").date()
            else:
                start_date = start_date_str
                
            if isinstance(end_date_str, str):
                if 'T' in end_date_str:
                    end_date = datetime.fromisoformat(end_date_str.replace('Z', '+00:00')).date()
                else:
                    end_date = datetime.strptime(end_date_str, "%Y-%m-%d").date()
            else:
                end_date = end_date_str
            
            operations = self.operations_manager.get_operations_by_date_range(start_date, end_date)
            
            return {
                "status": "success",
                "result": {
                    "start_date": start_date.isoformat(),
                    "end_date": end_date.isoformat(),
                    "operations": [op.to_dict() for op in operations],
                    "count": len(operations)
                }
            }
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des opérations par période: {str(e)}")
            return {
                "status": "error",
                "error_message": f"Erreur lors de la récupération des opérations par période: {str(e)}"
            }
    
    # --- Actions d'évaluation des performances ---
    
    def evaluate_performance(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Évalue la performance d'une opération forestière.
        
        Args:
            params: Paramètres incluant 'operation_id' et données d'évaluation
            
        Returns:
            Dictionnaire contenant le résultat de l'évaluation
        """
        operation_id = params.get("operation_id")
        operator_id = params.get("operator_id")
        
        if not operation_id and not operator_id:
            return {
                "status": "error",
                "error_message": "L'identifiant de l'opération ou de l'opérateur est requis"
            }
        
        try:
            # Préparer les données d'évaluation
            scores_data = params.get("scores", [])
            
            # Vérifier si nous avons au moins un score
            if not scores_data:
                return {
                    "status": "error",
                    "error_message": "Au moins un score d'évaluation est requis"
                }
            
            # Préparer les données d'évaluation dans le format attendu
            evaluation_data = {
                "operation_id": operation_id,
                "operator_id": operator_id,
                "evaluator": params.get("evaluator"),
                "scores": scores_data,
                "strengths": params.get("strengths", []),
                "areas_for_improvement": params.get("areas_for_improvement", []),
                "recommendations": params.get("recommendations", []),
                "notes": params.get("notes", "")
            }
            
            evaluation = self.performance_manager.add_evaluation(evaluation_data)
            
            if not evaluation:
                return {
                    "status": "error",
                    "error_message": "Échec de l'enregistrement de l'évaluation"
                }
            
            return {
                "status": "success",
                "result": {
                    "evaluation_id": evaluation.id,
                    "operation_id": operation_id,
                    "operator_id": operator_id,
                    "overall_score": evaluation.overall_score,
                    "message": "Évaluation de performance enregistrée avec succès"
                }
            }
        except Exception as e:
            logger.error(f"Erreur lors de l'évaluation de performance: {str(e)}")
            return {
                "status": "error",
                "error_message": f"Erreur lors de l'évaluation de performance: {str(e)}"
            }
    
    def get_operator_performance_summary(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Récupère un résumé de performance pour un opérateur.
        
        Args:
            params: Paramètres incluant 'operator_id'
            
        Returns:
            Dictionnaire contenant le résumé des performances
        """
        operator_id = params.get("operator_id")
        if not operator_id:
            return {
                "status": "error",
                "error_message": "L'identifiant de l'opérateur est requis"
            }
        
        try:
            # Convertir les dates si fournies
            period_start = params.get("period_start")
            if isinstance(period_start, str):
                period_start = datetime.fromisoformat(period_start.replace('Z', '+00:00'))
                
            period_end = params.get("period_end")
            if isinstance(period_end, str):
                period_end = datetime.fromisoformat(period_end.replace('Z', '+00:00'))
            
            summary = self.performance_manager.generate_operator_summary(
                operator_id=operator_id,
                period_start=period_start,
                period_end=period_end,
                operations_count=params.get("operations_count", 0),
                operations_completed=params.get("operations_completed", 0)
            )
            
            if not summary:
                return {
                    "status": "error",
                    "error_message": "Échec de la génération du résumé de performance"
                }
            
            return {
                "status": "success",
                "result": summary.to_dict()
            }
        except Exception as e:
            logger.error(f"Erreur lors de la récupération du résumé de performance pour l'opérateur {operator_id}: {str(e)}")
            return {
                "status": "error",
                "error_message": f"Erreur lors de la récupération du résumé de performance: {str(e)}"
            }
    
    def generate_performance_report(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Génère un rapport de performance pour un opérateur ou une opération.
        
        Args:
            params: Paramètres spécifiant l'opérateur ou l'opération
            
        Returns:
            Dictionnaire contenant le rapport généré
        """
        # Vérifier qu'au moins un des paramètres est présent
        operator_id = params.get("operator_id")
        operation_id = params.get("operation_id")
        
        if not operator_id and not operation_id:
            return {
                "status": "error",
                "error_message": "Au moins l'identifiant de l'opérateur ou de l'opération est requis"
            }
        
        try:
            report = self.performance_manager.generate_performance_report(params)
            
            if not report:
                return {
                    "status": "error",
                    "error_message": "Échec de la génération du rapport de performance"
                }
            
            # Préparer les formats disponibles
            formats = ["json"]
            # Les autres formats (pdf, html) seraient générés par un service distinct
            
            return {
                "status": "success",
                "result": {
                    "report_id": report.id,
                    "title": report.title,
                    "generated_at": report.generated_at.isoformat(),
                    "period": {
                        "start": report.period_start.isoformat(),
                        "end": report.period_end.isoformat()
                    },
                    "summary": report.summary,
                    "recommendations": report.recommendations,
                    "formats": formats,
                    "message": "Rapport de performance généré avec succès"
                }
            }
        except Exception as e:
            logger.error(f"Erreur lors de la génération du rapport de performance: {str(e)}")
            return {
                "status": "error",
                "error_message": f"Erreur lors de la génération du rapport de performance: {str(e)}"
            }
