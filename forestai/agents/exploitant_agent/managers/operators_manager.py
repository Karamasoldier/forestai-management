# -*- coding: utf-8 -*-
"""
Gestionnaire des opérateurs forestiers.

Ce module contient les fonctions de gestion des opérateurs forestiers,
incluant la création, la modification, et la recherche.
"""

import json
import uuid
import logging
import os
from typing import List, Dict, Any, Optional, Union
from datetime import datetime
from pathlib import Path

from forestai.core.utils.logging_utils import get_logger
from forestai.agents.exploitant_agent.models.operator_models import (
    Operator, OperatorType, ContactInfo, Address, Equipment
)

logger = get_logger(__name__)

class OperatorsManager:
    """
    Gestionnaire des opérateurs forestiers.
    
    Cette classe fournit les méthodes pour manipuler les opérateurs forestiers,
    incluant la création, la modification, la suppression et la recherche.
    """
    
    def __init__(self, data_dir: Optional[Path] = None):
        """
        Initialise le gestionnaire des opérateurs.
        
        Args:
            data_dir: Répertoire de stockage des données (facultatif)
        """
        # Si aucun répertoire n'est spécifié, utiliser le dossier par défaut
        if data_dir is None:
            data_dir = Path(os.environ.get("FORESTAI_DATA_DIR", ".")) / "data" / "operators"
        
        self.data_dir = data_dir
        self.operators_file = self.data_dir / "operators.json"
        
        # Créer le répertoire si nécessaire
        self.data_dir.mkdir(parents=True, exist_ok=True)
        
        # Charger les opérateurs existants
        self.operators = self._load_operators()
        
        logger.info(f"OperatorsManager initialisé avec {len(self.operators)} opérateurs")
    
    def _load_operators(self) -> Dict[str, Operator]:
        """
        Charge les opérateurs à partir du fichier de stockage.
        
        Returns:
            Dictionnaire des opérateurs indexés par leur identifiant
        """
        operators = {}
        
        # Si le fichier existe, charger les données
        if self.operators_file.exists():
            try:
                with open(self.operators_file, 'r', encoding='utf-8') as f:
                    operators_data = json.load(f)
                
                for operator_data in operators_data:
                    try:
                        operator = Operator.from_dict(operator_data)
                        operators[operator.id] = operator
                    except Exception as e:
                        logger.error(f"Erreur lors du chargement de l'opérateur: {str(e)}")
                        
            except Exception as e:
                logger.error(f"Erreur lors du chargement des opérateurs: {str(e)}")
        
        return operators
    
    def _save_operators(self) -> bool:
        """
        Sauvegarde les opérateurs dans le fichier de stockage.
        
        Returns:
            True si la sauvegarde a réussi, False sinon
        """
        try:
            operators_data = [operator.to_dict() for operator in self.operators.values()]
            
            with open(self.operators_file, 'w', encoding='utf-8') as f:
                json.dump(operators_data, f, ensure_ascii=False, indent=2)
                
            return True
            
        except Exception as e:
            logger.error(f"Erreur lors de la sauvegarde des opérateurs: {str(e)}")
            return False
    
    def get_operators(self, filters: Optional[Dict[str, Any]] = None) -> List[Operator]:
        """
        Récupère les opérateurs selon les filtres spécifiés.
        
        Args:
            filters: Filtres à appliquer (facultatif)
            
        Returns:
            Liste des opérateurs correspondant aux filtres
        """
        if not filters:
            # Retourner tous les opérateurs actifs par défaut
            return [op for op in self.operators.values() if op.active]
        
        result = []
        
        for operator in self.operators.values():
            # Filtrer par défaut les opérateurs inactifs sauf si demandé
            if not operator.active and not filters.get("include_inactive", False):
                continue
                
            # Appliquer les filtres
            match = True
            
            # Filtre par type
            if "type" in filters:
                filter_type = filters["type"]
                if isinstance(filter_type, str):
                    # Si c'est une chaîne, essayer de la convertir en type d'opérateur
                    try:
                        filter_type = OperatorType.from_string(filter_type)
                    except ValueError:
                        match = False
                
                if isinstance(filter_type, OperatorType) and operator.type != filter_type:
                    match = False
            
            # Filtre par nom
            if "name" in filters and filters["name"]:
                if filters["name"].lower() not in operator.name.lower():
                    match = False
            
            # Filtre par certification
            if "certification" in filters and filters["certification"]:
                cert_filter = filters["certification"].lower()
                if not any(cert.value.lower() == cert_filter for cert in operator.certifications):
                    match = False
            
            # Filtre par spécialité
            if "specialty" in filters and filters["specialty"]:
                specialty_filter = filters["specialty"].lower()
                if not any(specialty.lower() == specialty_filter for specialty in operator.specialties):
                    match = False
            
            # Filtre par zone de travail
            if "work_zone" in filters and filters["work_zone"]:
                zone_filter = filters["work_zone"].lower()
                if not any(zone.lower() == zone_filter for zone in operator.work_zones):
                    match = False
            
            # Ajouter l'opérateur s'il correspond aux filtres
            if match:
                result.append(operator)
        
        return result
    
    def get_operator(self, operator_id: str) -> Optional[Operator]:
        """
        Récupère un opérateur par son identifiant.
        
        Args:
            operator_id: Identifiant de l'opérateur
            
        Returns:
            Opérateur correspondant ou None s'il n'existe pas
        """
        return self.operators.get(operator_id)
    
    def add_operator(self, operator_data: Dict[str, Any]) -> Optional[Operator]:
        """
        Ajoute un nouvel opérateur.
        
        Args:
            operator_data: Données de l'opérateur
            
        Returns:
            Nouvel opérateur créé ou None en cas d'erreur
        """
        try:
            # Générer un identifiant unique
            operator_id = operator_data.get("id")
            if not operator_id:
                operator_id = f"op-{uuid.uuid4().hex[:8]}"
                operator_data["id"] = operator_id
            
            # S'assurer que l'id n'existe pas déjà
            if operator_id in self.operators:
                logger.error(f"Un opérateur avec l'identifiant {operator_id} existe déjà")
                return None
            
            # Créer l'opérateur
            operator = Operator.from_dict(operator_data)
            
            # Ajouter l'opérateur à la collection
            self.operators[operator.id] = operator
            
            # Sauvegarder les changements
            self._save_operators()
            
            logger.info(f"Opérateur {operator.name} (ID: {operator.id}) ajouté avec succès")
            return operator
            
        except Exception as e:
            logger.error(f"Erreur lors de l'ajout de l'opérateur: {str(e)}")
            return None
    
    def update_operator(self, operator_id: str, operator_data: Dict[str, Any]) -> Optional[Operator]:
        """
        Met à jour un opérateur existant.
        
        Args:
            operator_id: Identifiant de l'opérateur à mettre à jour
            operator_data: Nouvelles données de l'opérateur
            
        Returns:
            Opérateur mis à jour ou None en cas d'erreur
        """
        # Vérifier que l'opérateur existe
        if operator_id not in self.operators:
            logger.error(f"Opérateur avec ID {operator_id} non trouvé")
            return None
        
        try:
            # Récupérer l'opérateur existant
            existing_operator = self.operators[operator_id]
            
            # Créer un dictionnaire avec les données existantes
            updated_data = existing_operator.to_dict()
            
            # Mettre à jour uniquement les champs fournis
            for key, value in operator_data.items():
                # Ignorer l'ID car on ne peut pas le changer
                if key != "id":
                    updated_data[key] = value
            
            # Mettre à jour la date de mise à jour
            updated_data["updated_at"] = datetime.now().isoformat()
            
            # Créer l'opérateur mis à jour
            updated_operator = Operator.from_dict(updated_data)
            
            # Mettre à jour l'opérateur dans la collection
            self.operators[operator_id] = updated_operator
            
            # Sauvegarder les changements
            self._save_operators()
            
            logger.info(f"Opérateur {updated_operator.name} (ID: {operator_id}) mis à jour avec succès")
            return updated_operator
            
        except Exception as e:
            logger.error(f"Erreur lors de la mise à jour de l'opérateur: {str(e)}")
            return None
    
    def delete_operator(self, operator_id: str) -> bool:
        """
        Supprime un opérateur (le marque comme inactif).
        
        Args:
            operator_id: Identifiant de l'opérateur à supprimer
            
        Returns:
            True si la suppression a réussi, False sinon
        """
        # Vérifier que l'opérateur existe
        if operator_id not in self.operators:
            logger.error(f"Opérateur avec ID {operator_id} non trouvé")
            return False
        
        try:
            # Marquer comme inactif plutôt que de supprimer complètement
            self.operators[operator_id].active = False
            self.operators[operator_id].updated_at = datetime.now()
            
            # Sauvegarder les changements
            self._save_operators()
            
            logger.info(f"Opérateur avec ID {operator_id} marqué comme inactif avec succès")
            return True
            
        except Exception as e:
            logger.error(f"Erreur lors de la désactivation de l'opérateur: {str(e)}")
            return False
    
    def hard_delete_operator(self, operator_id: str) -> bool:
        """
        Supprime définitivement un opérateur.
        
        Args:
            operator_id: Identifiant de l'opérateur à supprimer
            
        Returns:
            True si la suppression a réussi, False sinon
        """
        # Vérifier que l'opérateur existe
        if operator_id not in self.operators:
            logger.error(f"Opérateur avec ID {operator_id} non trouvé")
            return False
        
        try:
            # Supprimer l'opérateur de la collection
            del self.operators[operator_id]
            
            # Sauvegarder les changements
            self._save_operators()
            
            logger.info(f"Opérateur avec ID {operator_id} supprimé définitivement avec succès")
            return True
            
        except Exception as e:
            logger.error(f"Erreur lors de la suppression définitive de l'opérateur: {str(e)}")
            return False
    
    def search_operators(self, query: str) -> List[Operator]:
        """
        Recherche des opérateurs par nom, spécialité, ou zone de travail.
        
        Args:
            query: Terme de recherche
            
        Returns:
            Liste des opérateurs correspondant à la recherche
        """
        if not query:
            return []
        
        query = query.lower()
        result = []
        
        for operator in self.operators.values():
            # Ne pas inclure les opérateurs inactifs
            if not operator.active:
                continue
            
            # Rechercher dans le nom
            if query in operator.name.lower():
                result.append(operator)
                continue
            
            # Rechercher dans les spécialités
            if any(query in specialty.lower() for specialty in operator.specialties):
                result.append(operator)
                continue
            
            # Rechercher dans les zones de travail
            if any(query in zone.lower() for zone in operator.work_zones):
                result.append(operator)
                continue
            
            # Rechercher dans le SIRET ou numéro de TVA
            if operator.siret and query in operator.siret.lower():
                result.append(operator)
                continue
                
            if operator.vat_number and query in operator.vat_number.lower():
                result.append(operator)
                continue
            
            # Rechercher dans les notes
            if query in operator.notes.lower():
                result.append(operator)
                continue
        
        return result
