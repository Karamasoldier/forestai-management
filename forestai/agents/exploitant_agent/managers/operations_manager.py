# -*- coding: utf-8 -*-
"""
Gestionnaire des opérations forestières.

Ce module contient les fonctions de gestion des opérations forestières,
incluant la planification, le suivi et la mise à jour.
"""

import json
import uuid
import logging
import os
from typing import List, Dict, Any, Optional, Union
from datetime import datetime, date
from pathlib import Path

from forestai.core.utils.logging_utils import get_logger
from forestai.agents.exploitant_agent.models.operation_models import (
    ForestOperation, OperationType, OperationStatus, Location, 
    OperationSchedule, StatusChange
)

logger = get_logger(__name__)

class OperationsManager:
    """
    Gestionnaire des opérations forestières.
    
    Cette classe fournit les méthodes pour manipuler les opérations forestières,
    incluant la planification, le suivi et la mise à jour.
    """
    
    def __init__(self, data_dir: Optional[Path] = None):
        """
        Initialise le gestionnaire des opérations.
        
        Args:
            data_dir: Répertoire de stockage des données (facultatif)
        """
        # Si aucun répertoire n'est spécifié, utiliser le dossier par défaut
        if data_dir is None:
            data_dir = Path(os.environ.get("FORESTAI_DATA_DIR", ".")) / "data" / "operations"
        
        self.data_dir = data_dir
        self.operations_file = self.data_dir / "operations.json"
        
        # Créer le répertoire si nécessaire
        self.data_dir.mkdir(parents=True, exist_ok=True)
        
        # Charger les opérations existantes
        self.operations = self._load_operations()
        
        logger.info(f"OperationsManager initialisé avec {len(self.operations)} opérations")
    
    def _load_operations(self) -> Dict[str, ForestOperation]:
        """
        Charge les opérations à partir du fichier de stockage.
        
        Returns:
            Dictionnaire des opérations indexées par leur identifiant
        """
        operations = {}
        
        # Si le fichier existe, charger les données
        if self.operations_file.exists():
            try:
                with open(self.operations_file, 'r', encoding='utf-8') as f:
                    operations_data = json.load(f)
                
                for operation_data in operations_data:
                    try:
                        operation = ForestOperation.from_dict(operation_data)
                        operations[operation.id] = operation
                    except Exception as e:
                        logger.error(f"Erreur lors du chargement de l'opération: {str(e)}")
                        
            except Exception as e:
                logger.error(f"Erreur lors du chargement des opérations: {str(e)}")
        
        return operations
    
    def _save_operations(self) -> bool:
        """
        Sauvegarde les opérations dans le fichier de stockage.
        
        Returns:
            True si la sauvegarde a réussi, False sinon
        """
        try:
            operations_data = [operation.to_dict() for operation in self.operations.values()]
            
            with open(self.operations_file, 'w', encoding='utf-8') as f:
                json.dump(operations_data, f, ensure_ascii=False, indent=2)
                
            return True
            
        except Exception as e:
            logger.error(f"Erreur lors de la sauvegarde des opérations: {str(e)}")
            return False
    
    def get_operations(self, filters: Optional[Dict[str, Any]] = None) -> List[ForestOperation]:
        """
        Récupère les opérations selon les filtres spécifiés.
        
        Args:
            filters: Filtres à appliquer (facultatif)
            
        Returns:
            Liste des opérations correspondant aux filtres
        """
        if not filters:
            # Retourner toutes les opérations
            return list(self.operations.values())
        
        result = []
        
        for operation in self.operations.values():
            # Appliquer les filtres
            match = True
            
            # Filtre par type
            if "type" in filters:
                filter_type = filters["type"]
                if isinstance(filter_type, str):
                    # Si c'est une chaîne, essayer de la convertir en type d'opération
                    try:
                        filter_type = OperationType.from_string(filter_type)
                    except ValueError:
                        match = False
                
                if isinstance(filter_type, OperationType) and operation.type != filter_type:
                    match = False
            
            # Filtre par statut
            if "status" in filters:
                filter_status = filters["status"]
                if isinstance(filter_status, str):
                    # Si c'est une chaîne, essayer de la convertir en statut d'opération
                    try:
                        filter_status = OperationStatus.from_string(filter_status)
                    except ValueError:
                        match = False
                
                if isinstance(filter_status, OperationStatus) and operation.status != filter_status:
                    match = False
            
            # Filtre par opérateur
            if "operator_id" in filters and filters["operator_id"]:
                if operation.operator_id != filters["operator_id"]:
                    match = False
            
            # Filtre par parcelle
            if "parcel_id" in filters and filters["parcel_id"]:
                if operation.location.parcel_id != filters["parcel_id"]:
                    match = False
            
            # Filtre par commune
            if "commune" in filters and filters["commune"]:
                if not operation.location.commune or filters["commune"].lower() not in operation.location.commune.lower():
                    match = False
            
            # Filtre par période (début)
            if "start_after" in filters and filters["start_after"]:
                start_after = filters["start_after"]
                if isinstance(start_after, str):
                    start_after = datetime.fromisoformat(start_after.replace("Z", "+00:00")).date()
                
                if not operation.schedule.start_date or operation.schedule.start_date < start_after:
                    match = False
            
            # Filtre par période (fin)
            if "end_before" in filters and filters["end_before"]:
                end_before = filters["end_before"]
                if isinstance(end_before, str):
                    end_before = datetime.fromisoformat(end_before.replace("Z", "+00:00")).date()
                
                if not operation.schedule.end_date or operation.schedule.end_date > end_before:
                    match = False
            
            # Ajouter l'opération si elle correspond aux filtres
            if match:
                result.append(operation)
        
        return result
    
    def get_operation(self, operation_id: str) -> Optional[ForestOperation]:
        """
        Récupère une opération par son identifiant.
        
        Args:
            operation_id: Identifiant de l'opération
            
        Returns:
            Opération correspondante ou None si elle n'existe pas
        """
        return self.operations.get(operation_id)
    
    def add_operation(self, operation_data: Dict[str, Any]) -> Optional[ForestOperation]:
        """
        Ajoute une nouvelle opération.
        
        Args:
            operation_data: Données de l'opération
            
        Returns:
            Nouvelle opération créée ou None en cas d'erreur
        """
        try:
            # Générer un identifiant unique
            operation_id = operation_data.get("id")
            if not operation_id:
                operation_id = f"op-{uuid.uuid4().hex[:8]}"
                operation_data["id"] = operation_id
            
            # S'assurer que l'id n'existe pas déjà
            if operation_id in self.operations:
                logger.error(f"Une opération avec l'identifiant {operation_id} existe déjà")
                return None
            
            # Créer l'opération
            operation = ForestOperation.from_dict(operation_data)
            
            # Ajouter l'opération à la collection
            self.operations[operation.id] = operation
            
            # Sauvegarder les changements
            self._save_operations()
            
            logger.info(f"Opération de type {operation.type.value} (ID: {operation.id}) ajoutée avec succès")
            return operation
            
        except Exception as e:
            logger.error(f"Erreur lors de l'ajout de l'opération: {str(e)}")
            return None
    
    def update_operation(self, operation_id: str, operation_data: Dict[str, Any]) -> Optional[ForestOperation]:
        """
        Met à jour une opération existante.
        
        Args:
            operation_id: Identifiant de l'opération à mettre à jour
            operation_data: Nouvelles données de l'opération
            
        Returns:
            Opération mise à jour ou None en cas d'erreur
        """
        # Vérifier que l'opération existe
        if operation_id not in self.operations:
            logger.error(f"Opération avec ID {operation_id} non trouvée")
            return None
        
        try:
            # Récupérer l'opération existante
            existing_operation = self.operations[operation_id]
            
            # Créer un dictionnaire avec les données existantes
            updated_data = existing_operation.to_dict()
            
            # Mettre à jour uniquement les champs fournis
            for key, value in operation_data.items():
                # Ignorer l'ID car on ne peut pas le changer
                if key != "id":
                    updated_data[key] = value
            
            # Mettre à jour la date de mise à jour
            updated_data["updated_at"] = datetime.now().isoformat()
            
            # Créer l'opération mise à jour
            updated_operation = ForestOperation.from_dict(updated_data)
            
            # Mettre à jour l'opération dans la collection
            self.operations[operation_id] = updated_operation
            
            # Sauvegarder les changements
            self._save_operations()
            
            logger.info(f"Opération de type {updated_operation.type.value} (ID: {operation_id}) mise à jour avec succès")
            return updated_operation
            
        except Exception as e:
            logger.error(f"Erreur lors de la mise à jour de l'opération: {str(e)}")
            return None
    
    def update_operation_status(self, operation_id: str, new_status: Union[str, OperationStatus], 
                              comment: Optional[str] = None, user: Optional[str] = None) -> Optional[ForestOperation]:
        """
        Met à jour le statut d'une opération.
        
        Args:
            operation_id: Identifiant de l'opération
            new_status: Nouveau statut (chaîne ou énumération)
            comment: Commentaire sur le changement de statut (facultatif)
            user: Utilisateur effectuant le changement (facultatif)
            
        Returns:
            Opération mise à jour ou None en cas d'erreur
        """
        # Vérifier que l'opération existe
        if operation_id not in self.operations:
            logger.error(f"Opération avec ID {operation_id} non trouvée")
            return None
        
        try:
            # Récupérer l'opération
            operation = self.operations[operation_id]
            
            # Convertir le statut si nécessaire
            if isinstance(new_status, str):
                status = OperationStatus.from_string(new_status)
            else:
                status = new_status
            
            # Mettre à jour le statut
            operation.update_status(status, comment, user)
            
            # Sauvegarder les changements
            self._save_operations()
            
            logger.info(f"Statut de l'opération {operation_id} mis à jour: {status.value}")
            return operation
            
        except Exception as e:
            logger.error(f"Erreur lors de la mise à jour du statut de l'opération: {str(e)}")
            return None
    
    def delete_operation(self, operation_id: str) -> bool:
        """
        Supprime une opération.
        
        Args:
            operation_id: Identifiant de l'opération à supprimer
            
        Returns:
            True si la suppression a réussi, False sinon
        """
        # Vérifier que l'opération existe
        if operation_id not in self.operations:
            logger.error(f"Opération avec ID {operation_id} non trouvée")
            return False
        
        try:
            # Supprimer l'opération de la collection
            del self.operations[operation_id]
            
            # Sauvegarder les changements
            self._save_operations()
            
            logger.info(f"Opération avec ID {operation_id} supprimée avec succès")
            return True
            
        except Exception as e:
            logger.error(f"Erreur lors de la suppression de l'opération: {str(e)}")
            return False
    
    def get_operations_by_date_range(self, start_date: date, end_date: date) -> List[ForestOperation]:
        """
        Récupère les opérations prévues dans une plage de dates.
        
        Args:
            start_date: Date de début de la plage
            end_date: Date de fin de la plage
            
        Returns:
            Liste des opérations dans la plage de dates
        """
        result = []
        
        for operation in self.operations.values():
            # Ignorer les opérations sans dates de planning
            if not operation.schedule.start_date:
                continue
            
            # Vérifier si l'opération est dans la plage
            if operation.schedule.end_date:
                # Si l'opération a une date de fin, vérifier le chevauchement
                if operation.schedule.start_date <= end_date and operation.schedule.end_date >= start_date:
                    result.append(operation)
            else:
                # Si l'opération n'a pas de date de fin, vérifier seulement la date de début
                if operation.schedule.start_date <= end_date and operation.schedule.start_date >= start_date:
                    result.append(operation)
        
        return result
    
    def get_operations_by_operator(self, operator_id: str) -> List[ForestOperation]:
        """
        Récupère les opérations associées à un opérateur.
        
        Args:
            operator_id: Identifiant de l'opérateur
            
        Returns:
            Liste des opérations de l'opérateur
        """
        return [op for op in self.operations.values() if op.operator_id == operator_id]
    
    def get_operations_by_parcel(self, parcel_id: str) -> List[ForestOperation]:
        """
        Récupère les opérations associées à une parcelle.
        
        Args:
            parcel_id: Identifiant de la parcelle
            
        Returns:
            Liste des opérations sur la parcelle
        """
        return [op for op in self.operations.values() if op.location.parcel_id == parcel_id]
    
    def search_operations(self, query: str) -> List[ForestOperation]:
        """
        Recherche des opérations par description ou lieu.
        
        Args:
            query: Terme de recherche
            
        Returns:
            Liste des opérations correspondant à la recherche
        """
        if not query:
            return []
        
        query = query.lower()
        result = []
        
        for operation in self.operations.values():
            # Rechercher dans la description
            if query in operation.description.lower():
                result.append(operation)
                continue
            
            # Rechercher dans les notes
            if query in operation.notes.lower():
                result.append(operation)
                continue
            
            # Rechercher dans la commune
            if operation.location.commune and query in operation.location.commune.lower():
                result.append(operation)
                continue
                
            # Rechercher dans le lieu-dit
            if operation.location.lieu_dit and query in operation.location.lieu_dit.lower():
                result.append(operation)
                continue
            
            # Rechercher dans les tags
            if any(query in tag.lower() for tag in operation.tags):
                result.append(operation)
                continue
        
        return result
