# -*- coding: utf-8 -*-
"""
Modèles de données pour les opérations forestières.

Ce module définit les classes et structures de données représentant
les opérations forestières et leurs statuts.
"""

from enum import Enum, auto
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Union
from datetime import datetime, date

from forestai.agents.exploitant_agent.models.operator_models import Operator


class OperationType(Enum):
    """Types d'opérations forestières."""
    
    COUPE_ECLAIRCIE = "Coupe d'éclaircie"
    COUPE_RASE = "Coupe rase"
    COUPE_JARDINAGE = "Coupe de jardinage"
    COUPE_SANITAIRE = "Coupe sanitaire"
    DEBARDAGE = "Débardage"
    PREPARATION_SOL = "Préparation du sol"
    PLANTATION = "Plantation"
    DEPRESSAGE = "Dépressage"
    ELAGAGE = "Élagage"
    DEBROUSSAILLAGE = "Débroussaillage"
    CREATION_PISTE = "Création de piste"
    ENTRETIEN_PISTE = "Entretien de piste"
    SYLVICULTURE = "Travaux sylvicoles"
    INVENTAIRE = "Inventaire forestier"
    MARTELAGE = "Martelage"
    AUTRE = "Autre"
    
    @classmethod
    def from_string(cls, value: str) -> 'OperationType':
        """
        Convertit une chaîne en type d'opération.
        
        Args:
            value: Chaîne à convertir
            
        Returns:
            Type d'opération correspondant
        """
        for operation_type in cls:
            if value.lower() == operation_type.value.lower():
                return operation_type
            
        # Mappings pour les termes similaires
        mappings = {
            "eclaircie": cls.COUPE_ECLAIRCIE,
            "coupe d'amélioration": cls.COUPE_ECLAIRCIE,
            "coupe finale": cls.COUPE_RASE,
            "rase": cls.COUPE_RASE,
            "jardinage": cls.COUPE_JARDINAGE,
            "futaie jardinée": cls.COUPE_JARDINAGE,
            "sanitaire": cls.COUPE_SANITAIRE,
            "phytosanitaire": cls.COUPE_SANITAIRE,
            "débusquage": cls.DEBARDAGE,
            "sortie des bois": cls.DEBARDAGE,
            "preparation": cls.PREPARATION_SOL,
            "labour": cls.PREPARATION_SOL,
            "reboisement": cls.PLANTATION,
            "renouvellement": cls.PLANTATION,
            "régénération": cls.PLANTATION,
            "dégagement": cls.DEPRESSAGE,
            "nettoiement": cls.DEPRESSAGE,
            "taille": cls.ELAGAGE,
            "ébranchage": cls.ELAGAGE,
            "nettoyage": cls.DEBROUSSAILLAGE,
            "gyrobroyage": cls.DEBROUSSAILLAGE,
            "ouverture piste": cls.CREATION_PISTE,
            "création route": cls.CREATION_PISTE,
            "entretien desserte": cls.ENTRETIEN_PISTE,
            "entretien route": cls.ENTRETIEN_PISTE,
            "travaux": cls.SYLVICULTURE,
            "relevé": cls.INVENTAIRE,
            "comptage": cls.INVENTAIRE,
            "marquage": cls.MARTELAGE,
            "désignation": cls.MARTELAGE
        }
        
        for key, op_type in mappings.items():
            if key in value.lower():
                return op_type
        
        return cls.AUTRE


class OperationStatus(Enum):
    """Statuts possibles pour une opération forestière."""
    
    PLANIFIEE = "Planifiée"
    EN_COURS = "En cours"
    SUSPENDUE = "Suspendue"
    TERMINEE = "Terminée"
    ANNULEE = "Annulée"
    REPORTEE = "Reportée"
    
    @classmethod
    def from_string(cls, value: str) -> 'OperationStatus':
        """
        Convertit une chaîne en statut d'opération.
        
        Args:
            value: Chaîne à convertir
            
        Returns:
            Statut d'opération correspondant
        """
        for status in cls:
            if value.lower() == status.value.lower():
                return status
            
        # Mappings pour les termes similaires
        mappings = {
            "plan": cls.PLANIFIEE,
            "prévu": cls.PLANIFIEE,
            "programmé": cls.PLANIFIEE,
            "debut": cls.EN_COURS,
            "commencé": cls.EN_COURS,
            "en progres": cls.EN_COURS,
            "suspend": cls.SUSPENDUE,
            "pause": cls.SUSPENDUE,
            "arrêt": cls.SUSPENDUE,
            "stop": cls.SUSPENDUE,
            "termin": cls.TERMINEE,
            "fini": cls.TERMINEE,
            "complet": cls.TERMINEE,
            "achevé": cls.TERMINEE,
            "annul": cls.ANNULEE,
            "abandon": cls.ANNULEE,
            "report": cls.REPORTEE,
            "replanifié": cls.REPORTEE,
            "décalé": cls.REPORTEE
        }
        
        for key, status in mappings.items():
            if key in value.lower():
                return status
        
        # Par défaut, considérer comme planifiée
        return cls.PLANIFIEE


@dataclass
class Location:
    """Emplacement d'une opération forestière."""
    
    parcel_id: str
    area_ha: float
    commune: Optional[str] = None
    lieu_dit: Optional[str] = None
    coordinates: Optional[Dict[str, float]] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convertit l'emplacement en dictionnaire.
        
        Returns:
            Dictionnaire représentant l'emplacement
        """
        return {
            "parcel_id": self.parcel_id,
            "area_ha": self.area_ha,
            "commune": self.commune,
            "lieu_dit": self.lieu_dit,
            "coordinates": self.coordinates
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Location':
        """
        Crée un emplacement à partir d'un dictionnaire.
        
        Args:
            data: Dictionnaire contenant les données de l'emplacement
            
        Returns:
            Nouvelle instance de Location
        """
        return cls(
            parcel_id=data.get("parcel_id", ""),
            area_ha=float(data.get("area_ha", 0)),
            commune=data.get("commune"),
            lieu_dit=data.get("lieu_dit"),
            coordinates=data.get("coordinates")
        )


@dataclass
class OperationSchedule:
    """Planning d'une opération forestière."""
    
    start_date: Optional[date] = None
    end_date: Optional[date] = None
    estimated_duration_days: Optional[int] = None
    actual_start_date: Optional[date] = None
    actual_end_date: Optional[date] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convertit le planning en dictionnaire.
        
        Returns:
            Dictionnaire représentant le planning
        """
        return {
            "start_date": self.start_date.isoformat() if self.start_date else None,
            "end_date": self.end_date.isoformat() if self.end_date else None,
            "estimated_duration_days": self.estimated_duration_days,
            "actual_start_date": self.actual_start_date.isoformat() if self.actual_start_date else None,
            "actual_end_date": self.actual_end_date.isoformat() if self.actual_end_date else None
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'OperationSchedule':
        """
        Crée un planning à partir d'un dictionnaire.
        
        Args:
            data: Dictionnaire contenant les données du planning
            
        Returns:
            Nouvelle instance d'OperationSchedule
        """
        # Fonction pour parser une date ISO
        def parse_date(date_str: Optional[str]) -> Optional[date]:
            if not date_str:
                return None
            try:
                if 'T' in date_str:
                    return datetime.fromisoformat(date_str.replace('Z', '+00:00')).date()
                return date.fromisoformat(date_str)
            except ValueError:
                return None
        
        return cls(
            start_date=parse_date(data.get("start_date")),
            end_date=parse_date(data.get("end_date")),
            estimated_duration_days=data.get("estimated_duration_days"),
            actual_start_date=parse_date(data.get("actual_start_date")),
            actual_end_date=parse_date(data.get("actual_end_date"))
        )


@dataclass
class StatusChange:
    """Changement de statut d'une opération."""
    
    status: OperationStatus
    timestamp: datetime = field(default_factory=datetime.now)
    comment: Optional[str] = None
    user: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convertit le changement de statut en dictionnaire.
        
        Returns:
            Dictionnaire représentant le changement de statut
        """
        return {
            "status": self.status.value,
            "timestamp": self.timestamp.isoformat(),
            "comment": self.comment,
            "user": self.user
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'StatusChange':
        """
        Crée un changement de statut à partir d'un dictionnaire.
        
        Args:
            data: Dictionnaire contenant les données du changement de statut
            
        Returns:
            Nouvelle instance de StatusChange
        """
        status_str = data.get("status", "")
        status = OperationStatus.from_string(status_str)
        
        timestamp_str = data.get("timestamp")
        if timestamp_str:
            timestamp = datetime.fromisoformat(timestamp_str.replace('Z', '+00:00'))
        else:
            timestamp = datetime.now()
        
        return cls(
            status=status,
            timestamp=timestamp,
            comment=data.get("comment"),
            user=data.get("user")
        )


@dataclass
class ForestOperation:
    """
    Représentation d'une opération forestière.
    
    Cette classe contient toutes les informations relatives à une opération
    forestière, y compris son type, son emplacement, et son planning.
    """
    
    id: str
    type: OperationType
    description: str
    location: Location
    status: OperationStatus = OperationStatus.PLANIFIEE
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    
    operator_id: Optional[str] = None
    operator: Optional[Dict[str, Any]] = None
    
    schedule: OperationSchedule = field(default_factory=OperationSchedule)
    equipment: List[str] = field(default_factory=list)
    
    estimated_volume_m3: Optional[float] = None
    actual_volume_m3: Optional[float] = None
    
    status_history: List[StatusChange] = field(default_factory=list)
    
    notes: str = ""
    tags: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convertit l'opération en dictionnaire.
        
        Returns:
            Dictionnaire représentant l'opération
        """
        return {
            "id": self.id,
            "type": self.type.value,
            "description": self.description,
            "location": self.location.to_dict(),
            "status": self.status.value,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
            "operator_id": self.operator_id,
            "operator": self.operator,
            "schedule": self.schedule.to_dict(),
            "equipment": self.equipment,
            "estimated_volume_m3": self.estimated_volume_m3,
            "actual_volume_m3": self.actual_volume_m3,
            "status_history": [sh.to_dict() for sh in self.status_history],
            "notes": self.notes,
            "tags": self.tags
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ForestOperation':
        """
        Crée une opération à partir d'un dictionnaire.
        
        Args:
            data: Dictionnaire contenant les données de l'opération
            
        Returns:
            Nouvelle instance de ForestOperation
        """
        # Traiter les dates
        created_at = data.get("created_at")
        updated_at = data.get("updated_at")
        
        if isinstance(created_at, str):
            created_at = datetime.fromisoformat(created_at.replace("Z", "+00:00"))
        elif not isinstance(created_at, datetime):
            created_at = datetime.now()
            
        if isinstance(updated_at, str):
            updated_at = datetime.fromisoformat(updated_at.replace("Z", "+00:00"))
        elif not isinstance(updated_at, datetime):
            updated_at = datetime.now()
        
        # Traiter les objets imbriqués
        location_data = data.get("location", {})
        if isinstance(location_data, dict):
            location = Location.from_dict(location_data)
        else:
            location = Location(parcel_id="", area_ha=0)
            
        schedule_data = data.get("schedule", {})
        if isinstance(schedule_data, dict):
            schedule = OperationSchedule.from_dict(schedule_data)
        else:
            schedule = OperationSchedule()
            
        # Traiter l'historique des statuts
        status_history = []
        for sh_data in data.get("status_history", []):
            if isinstance(sh_data, dict):
                status_history.append(StatusChange.from_dict(sh_data))
        
        # Créer l'instance d'opération
        return cls(
            id=data.get("id", ""),
            type=OperationType.from_string(data.get("type", "AUTRE")),
            description=data.get("description", ""),
            location=location,
            status=OperationStatus.from_string(data.get("status", "PLANIFIEE")),
            created_at=created_at,
            updated_at=updated_at,
            operator_id=data.get("operator_id"),
            operator=data.get("operator"),
            schedule=schedule,
            equipment=data.get("equipment", []),
            estimated_volume_m3=data.get("estimated_volume_m3"),
            actual_volume_m3=data.get("actual_volume_m3"),
            status_history=status_history,
            notes=data.get("notes", ""),
            tags=data.get("tags", [])
        )
    
    def update_status(self, new_status: OperationStatus, comment: Optional[str] = None, user: Optional[str] = None) -> None:
        """
        Met à jour le statut de l'opération et enregistre le changement dans l'historique.
        
        Args:
            new_status: Nouveau statut
            comment: Commentaire optionnel
            user: Utilisateur ayant effectué le changement
        """
        if new_status != self.status:
            # Ajouter le changement à l'historique
            status_change = StatusChange(
                status=new_status,
                timestamp=datetime.now(),
                comment=comment,
                user=user
            )
            self.status_history.append(status_change)
            
            # Mettre à jour le statut et la date de mise à jour
            self.status = new_status
            self.updated_at = datetime.now()
            
            # Si le statut devient EN_COURS et qu'il n'y a pas de date de début réelle
            if new_status == OperationStatus.EN_COURS and not self.schedule.actual_start_date:
                self.schedule.actual_start_date = datetime.now().date()
                
            # Si le statut devient TERMINEE et qu'il n'y a pas de date de fin réelle
            if new_status == OperationStatus.TERMINEE and not self.schedule.actual_end_date:
                self.schedule.actual_end_date = datetime.now().date()
