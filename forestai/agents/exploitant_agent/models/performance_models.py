# -*- coding: utf-8 -*-
"""
Modèles de données pour l'évaluation des performances.

Ce module définit les classes et structures de données représentant
les évaluations de performance des opérateurs forestiers.
"""

from enum import Enum
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Union
from datetime import datetime


class PerformanceCriteria(Enum):
    """Critères d'évaluation des performances."""
    
    QUALITY = "Qualité du travail"
    TIMELINESS = "Respect des délais"
    ENVIRONMENTAL_IMPACT = "Impact environnemental"
    COMPLIANCE = "Conformité réglementaire"
    COMMUNICATION = "Communication"
    EFFICIENCY = "Efficacité"
    SAFETY = "Sécurité"
    OVERALL = "Évaluation globale"


@dataclass
class ScoreEntry:
    """Entrée d'évaluation pour un critère spécifique."""
    
    criteria: PerformanceCriteria
    score: float  # Échelle de 1 à 5
    comments: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convertit l'entrée d'évaluation en dictionnaire.
        
        Returns:
            Dictionnaire représentant l'entrée d'évaluation
        """
        return {
            "criteria": self.criteria.value,
            "score": self.score,
            "comments": self.comments
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ScoreEntry':
        """
        Crée une entrée d'évaluation à partir d'un dictionnaire.
        
        Args:
            data: Dictionnaire contenant les données de l'entrée d'évaluation
            
        Returns:
            Nouvelle instance de ScoreEntry
        """
        criteria_str = data.get("criteria", "")
        criteria = next(
            (c for c in PerformanceCriteria if c.value == criteria_str),
            PerformanceCriteria.OVERALL
        )
        
        return cls(
            criteria=criteria,
            score=float(data.get("score", 0)),
            comments=data.get("comments")
        )


@dataclass
class PerformanceEvaluation:
    """
    Évaluation de performance pour une opération ou un opérateur.
    
    Cette classe représente une évaluation complète de performance, qui peut être
    associée à une opération forestière spécifique ou un opérateur.
    """
    
    id: str
    operation_id: Optional[str] = None
    operator_id: Optional[str] = None
    evaluated_at: datetime = field(default_factory=datetime.now)
    evaluator: Optional[str] = None
    
    scores: List[ScoreEntry] = field(default_factory=list)
    overall_score: Optional[float] = None
    
    strengths: List[str] = field(default_factory=list)
    areas_for_improvement: List[str] = field(default_factory=list)
    recommendations: List[str] = field(default_factory=list)
    
    notes: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convertit l'évaluation en dictionnaire.
        
        Returns:
            Dictionnaire représentant l'évaluation
        """
        return {
            "id": self.id,
            "operation_id": self.operation_id,
            "operator_id": self.operator_id,
            "evaluated_at": self.evaluated_at.isoformat(),
            "evaluator": self.evaluator,
            "scores": [score.to_dict() for score in self.scores],
            "overall_score": self.overall_score,
            "strengths": self.strengths,
            "areas_for_improvement": self.areas_for_improvement,
            "recommendations": self.recommendations,
            "notes": self.notes
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'PerformanceEvaluation':
        """
        Crée une évaluation à partir d'un dictionnaire.
        
        Args:
            data: Dictionnaire contenant les données de l'évaluation
            
        Returns:
            Nouvelle instance de PerformanceEvaluation
        """
        # Traiter la date d'évaluation
        evaluated_at = data.get("evaluated_at")
        if isinstance(evaluated_at, str):
            evaluated_at = datetime.fromisoformat(evaluated_at.replace("Z", "+00:00"))
        elif not isinstance(evaluated_at, datetime):
            evaluated_at = datetime.now()
        
        # Traiter les scores
        scores = []
        for score_data in data.get("scores", []):
            if isinstance(score_data, dict):
                scores.append(ScoreEntry.from_dict(score_data))
        
        # Créer l'instance d'évaluation
        return cls(
            id=data.get("id", ""),
            operation_id=data.get("operation_id"),
            operator_id=data.get("operator_id"),
            evaluated_at=evaluated_at,
            evaluator=data.get("evaluator"),
            scores=scores,
            overall_score=data.get("overall_score"),
            strengths=data.get("strengths", []),
            areas_for_improvement=data.get("areas_for_improvement", []),
            recommendations=data.get("recommendations", []),
            notes=data.get("notes", "")
        )
    
    def calculate_overall_score(self) -> float:
        """
        Calcule le score global basé sur les scores individuels.
        
        Returns:
            Score global (moyenne pondérée)
        """
        if not self.scores:
            return 0.0
        
        # Poids par défaut pour chaque critère
        weights = {
            PerformanceCriteria.QUALITY: 1.0,
            PerformanceCriteria.TIMELINESS: 0.8,
            PerformanceCriteria.ENVIRONMENTAL_IMPACT: 1.0,
            PerformanceCriteria.COMPLIANCE: 1.2,
            PerformanceCriteria.COMMUNICATION: 0.7,
            PerformanceCriteria.EFFICIENCY: 0.8,
            PerformanceCriteria.SAFETY: 1.2,
            PerformanceCriteria.OVERALL: 1.0
        }
        
        # Calcul de la moyenne pondérée
        total_weighted_score = 0.0
        total_weight = 0.0
        
        for score_entry in self.scores:
            # Ignorer le score global s'il est déjà présent
            if score_entry.criteria == PerformanceCriteria.OVERALL:
                continue
                
            weight = weights.get(score_entry.criteria, 1.0)
            total_weighted_score += score_entry.score * weight
            total_weight += weight
        
        # Calculer la moyenne si des poids ont été appliqués
        if total_weight > 0:
            overall = round(total_weighted_score / total_weight, 1)
        else:
            overall = 0.0
        
        self.overall_score = overall
        return overall


@dataclass
class OperatorPerformanceSummary:
    """
    Résumé des performances d'un opérateur sur une période donnée.
    
    Cette classe agrège plusieurs évaluations de performance pour
    fournir une vue d'ensemble des performances d'un opérateur.
    """
    
    operator_id: str
    period_start: datetime
    period_end: datetime
    
    evaluations_count: int = 0
    operations_count: int = 0
    operations_completed: int = 0
    
    average_scores: Dict[str, float] = field(default_factory=dict)
    overall_average: float = 0.0
    
    strengths_summary: List[str] = field(default_factory=list)
    improvement_areas_summary: List[str] = field(default_factory=list)
    recommendations_summary: List[str] = field(default_factory=list)
    
    trend: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convertit le résumé en dictionnaire.
        
        Returns:
            Dictionnaire représentant le résumé
        """
        return {
            "operator_id": self.operator_id,
            "period_start": self.period_start.isoformat(),
            "period_end": self.period_end.isoformat(),
            "evaluations_count": self.evaluations_count,
            "operations_count": self.operations_count,
            "operations_completed": self.operations_completed,
            "average_scores": self.average_scores,
            "overall_average": self.overall_average,
            "strengths_summary": self.strengths_summary,
            "improvement_areas_summary": self.improvement_areas_summary,
            "recommendations_summary": self.recommendations_summary,
            "trend": self.trend
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'OperatorPerformanceSummary':
        """
        Crée un résumé à partir d'un dictionnaire.
        
        Args:
            data: Dictionnaire contenant les données du résumé
            
        Returns:
            Nouvelle instance d'OperatorPerformanceSummary
        """
        # Traiter les dates
        period_start = data.get("period_start")
        if isinstance(period_start, str):
            period_start = datetime.fromisoformat(period_start.replace("Z", "+00:00"))
        elif not isinstance(period_start, datetime):
            period_start = datetime.now()
            
        period_end = data.get("period_end")
        if isinstance(period_end, str):
            period_end = datetime.fromisoformat(period_end.replace("Z", "+00:00"))
        elif not isinstance(period_end, datetime):
            period_end = datetime.now()
        
        # Créer l'instance de résumé
        return cls(
            operator_id=data.get("operator_id", ""),
            period_start=period_start,
            period_end=period_end,
            evaluations_count=data.get("evaluations_count", 0),
            operations_count=data.get("operations_count", 0),
            operations_completed=data.get("operations_completed", 0),
            average_scores=data.get("average_scores", {}),
            overall_average=data.get("overall_average", 0.0),
            strengths_summary=data.get("strengths_summary", []),
            improvement_areas_summary=data.get("improvement_areas_summary", []),
            recommendations_summary=data.get("recommendations_summary", []),
            trend=data.get("trend")
        )
    
    @classmethod
    def from_evaluations(cls, operator_id: str, evaluations: List[PerformanceEvaluation], 
                        period_start: datetime, period_end: datetime,
                        operations_count: int = 0, operations_completed: int = 0) -> 'OperatorPerformanceSummary':
        """
        Crée un résumé à partir d'une liste d'évaluations.
        
        Args:
            operator_id: Identifiant de l'opérateur
            evaluations: Liste des évaluations
            period_start: Date de début de la période
            period_end: Date de fin de la période
            operations_count: Nombre total d'opérations
            operations_completed: Nombre d'opérations terminées
            
        Returns:
            Résumé de performance
        """
        if not evaluations:
            return cls(
                operator_id=operator_id,
                period_start=period_start,
                period_end=period_end,
                operations_count=operations_count,
                operations_completed=operations_completed
            )
        
        # Calculer les scores moyens par critère
        criteria_scores: Dict[PerformanceCriteria, List[float]] = {}
        all_strengths = []
        all_improvements = []
        all_recommendations = []
        
        for evaluation in evaluations:
            # Agréger les scores par critère
            for score_entry in evaluation.scores:
                if score_entry.criteria not in criteria_scores:
                    criteria_scores[score_entry.criteria] = []
                criteria_scores[score_entry.criteria].append(score_entry.score)
            
            # Agréger les points forts, points d'amélioration et recommandations
            all_strengths.extend(evaluation.strengths)
            all_improvements.extend(evaluation.areas_for_improvement)
            all_recommendations.extend(evaluation.recommendations)
        
        # Calculer les moyennes par critère
        average_scores = {}
        for criteria, scores in criteria_scores.items():
            if scores:
                average_scores[criteria.value] = round(sum(scores) / len(scores), 1)
        
        # Calculer la moyenne globale
        overall_scores = criteria_scores.get(PerformanceCriteria.OVERALL, [])
        if overall_scores:
            overall_average = round(sum(overall_scores) / len(overall_scores), 1)
        else:
            # S'il n'y a pas de score global explicite, calculer à partir des autres critères
            all_scores = []
            for scores in criteria_scores.values():
                all_scores.extend(scores)
            
            if all_scores:
                overall_average = round(sum(all_scores) / len(all_scores), 1)
            else:
                overall_average = 0.0
        
        # Synthétiser les points forts, points d'amélioration et recommandations
        # En comptant les occurrences et en prenant les plus fréquents
        strengths_count = {}
        for strength in all_strengths:
            strengths_count[strength] = strengths_count.get(strength, 0) + 1
        
        improvements_count = {}
        for improvement in all_improvements:
            improvements_count[improvement] = improvements_count.get(improvement, 0) + 1
        
        recommendations_count = {}
        for recommendation in all_recommendations:
            recommendations_count[recommendation] = recommendations_count.get(recommendation, 0) + 1
        
        # Prendre les 5 éléments les plus fréquents
        strengths_summary = sorted(strengths_count.items(), key=lambda x: x[1], reverse=True)[:5]
        improvement_areas_summary = sorted(improvements_count.items(), key=lambda x: x[1], reverse=True)[:5]
        recommendations_summary = sorted(recommendations_count.items(), key=lambda x: x[1], reverse=True)[:5]
        
        # Déterminer la tendance si possible (nécessite des évaluations chronologiques)
        trend = None
        if len(evaluations) >= 3:
            # Trier les évaluations par date
            sorted_evals = sorted(evaluations, key=lambda e: e.evaluated_at)
            
            # Comparer les scores globaux du premier tiers et du dernier tiers
            split_point = len(sorted_evals) // 3
            early_evals = sorted_evals[:split_point]
            late_evals = sorted_evals[-split_point:]
            
            early_scores = [e.overall_score for e in early_evals if e.overall_score is not None]
            late_scores = [e.overall_score for e in late_evals if e.overall_score is not None]
            
            if early_scores and late_scores:
                early_avg = sum(early_scores) / len(early_scores)
                late_avg = sum(late_scores) / len(late_scores)
                
                diff = late_avg - early_avg
                if diff > 0.5:
                    trend = "Amélioration significative"
                elif diff > 0.2:
                    trend = "Légère amélioration"
                elif diff < -0.5:
                    trend = "Dégradation significative"
                elif diff < -0.2:
                    trend = "Légère dégradation"
                else:
                    trend = "Stable"
        
        # Créer le résumé
        return cls(
            operator_id=operator_id,
            period_start=period_start,
            period_end=period_end,
            evaluations_count=len(evaluations),
            operations_count=operations_count,
            operations_completed=operations_completed,
            average_scores={k: v for k, v in average_scores.items()},
            overall_average=overall_average,
            strengths_summary=[s[0] for s in strengths_summary],
            improvement_areas_summary=[i[0] for i in improvement_areas_summary],
            recommendations_summary=[r[0] for r in recommendations_summary],
            trend=trend
        )


@dataclass
class PerformanceReport:
    """
    Rapport complet de performance.
    
    Cette classe représente un rapport de performance, qui peut inclure
    des évaluations individuelles et des résumés globaux.
    """
    
    id: str
    title: str
    generated_at: datetime = field(default_factory=datetime.now)
    period_start: datetime = field(default_factory=lambda: datetime(datetime.now().year, 1, 1))
    period_end: datetime = field(default_factory=datetime.now)
    
    operator_id: Optional[str] = None
    operation_id: Optional[str] = None
    
    summary: Dict[str, Any] = field(default_factory=dict)
    evaluations: List[Dict[str, Any]] = field(default_factory=list)
    recommendations: List[str] = field(default_factory=list)
    
    charts_data: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convertit le rapport en dictionnaire.
        
        Returns:
            Dictionnaire représentant le rapport
        """
        return {
            "id": self.id,
            "title": self.title,
            "generated_at": self.generated_at.isoformat(),
            "period_start": self.period_start.isoformat(),
            "period_end": self.period_end.isoformat(),
            "operator_id": self.operator_id,
            "operation_id": self.operation_id,
            "summary": self.summary,
            "evaluations": self.evaluations,
            "recommendations": self.recommendations,
            "charts_data": self.charts_data
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'PerformanceReport':
        """
        Crée un rapport à partir d'un dictionnaire.
        
        Args:
            data: Dictionnaire contenant les données du rapport
            
        Returns:
            Nouvelle instance de PerformanceReport
        """
        # Traiter les dates
        generated_at = data.get("generated_at")
        if isinstance(generated_at, str):
            generated_at = datetime.fromisoformat(generated_at.replace("Z", "+00:00"))
        elif not isinstance(generated_at, datetime):
            generated_at = datetime.now()
            
        period_start = data.get("period_start")
        if isinstance(period_start, str):
            period_start = datetime.fromisoformat(period_start.replace("Z", "+00:00"))
        elif not isinstance(period_start, datetime):
            period_start = datetime(datetime.now().year, 1, 1)
            
        period_end = data.get("period_end")
        if isinstance(period_end, str):
            period_end = datetime.fromisoformat(period_end.replace("Z", "+00:00"))
        elif not isinstance(period_end, datetime):
            period_end = datetime.now()
        
        # Créer l'instance de rapport
        return cls(
            id=data.get("id", ""),
            title=data.get("title", "Rapport de performance"),
            generated_at=generated_at,
            period_start=period_start,
            period_end=period_end,
            operator_id=data.get("operator_id"),
            operation_id=data.get("operation_id"),
            summary=data.get("summary", {}),
            evaluations=data.get("evaluations", []),
            recommendations=data.get("recommendations", []),
            charts_data=data.get("charts_data", {})
        )
