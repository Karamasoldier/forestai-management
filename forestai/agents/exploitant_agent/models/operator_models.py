# -*- coding: utf-8 -*-
"""
Modèles de données pour les opérateurs forestiers.

Ce module définit les classes et structures de données représentant
les opérateurs forestiers et leurs informations associées.
"""

from enum import Enum, auto
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
from datetime import datetime


class OperatorType(Enum):
    """Types d'opérateurs forestiers."""
    
    EXPLOITANT = auto()
    BUCHERON = auto()
    DEBARDEUR = auto()
    SYLVICULTEUR = auto()
    PLANTEUR = auto()
    ENTREPRENEUR_FORESTIER = auto()
    COOPERATIVE = auto()
    OTHER = auto()
    
    @classmethod
    def from_string(cls, value: str) -> 'OperatorType':
        """
        Convertit une chaîne en type d'opérateur.
        
        Args:
            value: Chaîne à convertir
            
        Returns:
            Type d'opérateur correspondant
        """
        value_upper = value.upper().replace(" ", "_").replace("-", "_")
        
        for member in cls:
            if member.name == value_upper:
                return member
        
        # Mappings spécifiques pour les termes courants
        mappings = {
            "EXPLOITATION": cls.EXPLOITANT,
            "EXPLOITATION_FORESTIERE": cls.EXPLOITANT,
            "BUCHERON_INDEPENDANT": cls.BUCHERON,
            "DEBARDAGE": cls.DEBARDEUR,
            "TRAVAUX_SYLVICOLES": cls.SYLVICULTEUR,
            "SYLVICULTURE": cls.SYLVICULTEUR,
            "PLANTATION": cls.PLANTEUR,
            "ENTREPRENEUR": cls.ENTREPRENEUR_FORESTIER,
            "ETF": cls.ENTREPRENEUR_FORESTIER,
            "COOP": cls.COOPERATIVE,
            "COOPERATIVE_FORESTIERE": cls.COOPERATIVE
        }
        
        if value_upper in mappings:
            return mappings[value_upper]
        
        return cls.OTHER


class CertificationType(Enum):
    """Types de certifications forestières."""
    
    PEFC = "PEFC"
    FSC = "FSC"
    ISO_14001 = "ISO 14001"
    QUALITERRITOIRES = "QualiTerritoires"
    ETF_GESTION_DURABLE = "ETF Gestion Durable"
    PRO_SILVA = "Pro Silva"
    OTHER = "Autre"


@dataclass
class ContactInfo:
    """Informations de contact pour un opérateur."""
    
    name: str
    email: Optional[str] = None
    phone: Optional[str] = None
    mobile: Optional[str] = None
    function: Optional[str] = None


@dataclass
class Address:
    """Adresse postale."""
    
    line1: str
    line2: Optional[str] = None
    postal_code: Optional[str] = None
    city: Optional[str] = None
    country: str = "France"


@dataclass
class Equipment:
    """Équipement forestier."""
    
    name: str
    type: str
    description: Optional[str] = None
    capacity: Optional[str] = None
    count: int = 1


@dataclass
class Operator:
    """
    Représentation d'un opérateur forestier.
    
    Cette classe contient toutes les informations relatives à un opérateur
    forestier, y compris ses coordonnées, certifications, et spécialités.
    """
    
    id: str
    name: str
    type: OperatorType
    contact: ContactInfo
    address: Address
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    
    siret: Optional[str] = None
    vat_number: Optional[str] = None
    website: Optional[str] = None
    
    certifications: List[CertificationType] = field(default_factory=list)
    specialties: List[str] = field(default_factory=list)
    work_zones: List[str] = field(default_factory=list)
    equipment: List[Equipment] = field(default_factory=list)
    
    notes: str = ""
    tags: List[str] = field(default_factory=list)
    
    active: bool = True
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convertit l'opérateur en dictionnaire.
        
        Returns:
            Dictionnaire représentant l'opérateur
        """
        return {
            "id": self.id,
            "name": self.name,
            "type": self.type.name,
            "contact": {
                "name": self.contact.name,
                "email": self.contact.email,
                "phone": self.contact.phone,
                "mobile": self.contact.mobile,
                "function": self.contact.function
            },
            "address": {
                "line1": self.address.line1,
                "line2": self.address.line2,
                "postal_code": self.address.postal_code,
                "city": self.address.city,
                "country": self.address.country
            },
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
            "siret": self.siret,
            "vat_number": self.vat_number,
            "website": self.website,
            "certifications": [cert.value for cert in self.certifications],
            "specialties": self.specialties,
            "work_zones": self.work_zones,
            "equipment": [
                {
                    "name": eq.name,
                    "type": eq.type,
                    "description": eq.description,
                    "capacity": eq.capacity,
                    "count": eq.count
                }
                for eq in self.equipment
            ],
            "notes": self.notes,
            "tags": self.tags,
            "active": self.active
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Operator':
        """
        Crée un opérateur à partir d'un dictionnaire.
        
        Args:
            data: Dictionnaire contenant les données de l'opérateur
            
        Returns:
            Nouvelle instance d'Operator
        """
        contact_data = data.get("contact", {})
        address_data = data.get("address", {})
        
        # Créer les objets imbriqués
        contact = ContactInfo(
            name=contact_data.get("name", ""),
            email=contact_data.get("email"),
            phone=contact_data.get("phone"),
            mobile=contact_data.get("mobile"),
            function=contact_data.get("function")
        )
        
        address = Address(
            line1=address_data.get("line1", ""),
            line2=address_data.get("line2"),
            postal_code=address_data.get("postal_code"),
            city=address_data.get("city"),
            country=address_data.get("country", "France")
        )
        
        # Traiter les dates
        created_at = data.get("created_at")
        updated_at = data.get("updated_at")
        
        if isinstance(created_at, str):
            created_at = datetime.fromisoformat(created_at.replace("Z", "+00:00"))
        elif not isinstance(created_at, datetime):
            created_at = datetime.now()
            
        if isinstance(updated_at, str):
            updated_at = datetime.fromisoformat(updated_at.replace("Z", "+00:00"))
        elif not isinstance(updated_at, datetime):
            updated_at = datetime.now()
        
        # Traiter les certifications
        certifications = []
        for cert_str in data.get("certifications", []):
            for cert_type in CertificationType:
                if cert_str == cert_type.value or cert_str.upper() == cert_type.name:
                    certifications.append(cert_type)
                    break
            else:
                certifications.append(CertificationType.OTHER)
        
        # Traiter les équipements
        equipment = []
        for eq_data in data.get("equipment", []):
            if isinstance(eq_data, dict):
                equipment.append(Equipment(
                    name=eq_data.get("name", ""),
                    type=eq_data.get("type", ""),
                    description=eq_data.get("description"),
                    capacity=eq_data.get("capacity"),
                    count=eq_data.get("count", 1)
                ))
        
        # Créer l'instance d'opérateur
        return cls(
            id=data.get("id", ""),
            name=data.get("name", ""),
            type=OperatorType.from_string(data.get("type", "OTHER")),
            contact=contact,
            address=address,
            created_at=created_at,
            updated_at=updated_at,
            siret=data.get("siret"),
            vat_number=data.get("vat_number"),
            website=data.get("website"),
            certifications=certifications,
            specialties=data.get("specialties", []),
            work_zones=data.get("work_zones", []),
            equipment=equipment,
            notes=data.get("notes", ""),
            tags=data.get("tags", []),
            active=data.get("active", True)
        )
